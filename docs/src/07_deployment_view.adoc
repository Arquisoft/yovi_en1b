ifndef::imagesdir[:imagesdir: ../images]

[[section-deployment-view]]


== Deployment View

ifdef::arc42help[]
[role="arc42help"]
****
.Content
The deployment view describes:

 1. technical infrastructure used to execute your system, with infrastructure elements like geographical locations, environments, computers, processors, channels and net topologies as well as other infrastructure elements and

2. mapping of (software) building blocks to that infrastructure elements.

Often systems are executed in different environments, e.g. development environment, test environment, production environment. In such cases you should document all relevant environments.

Especially document a deployment view if your software is executed as distributed system with more than one computer, processor, server or container or when you design and construct your own hardware processors and chips.

From a software perspective it is sufficient to capture only those elements of an infrastructure that are needed to show a deployment of your building blocks. Hardware architects can go beyond that and describe an infrastructure to any level of detail they need to capture.

.Motivation
Software does not run without hardware.
This underlying infrastructure can and will influence a system and/or some
cross-cutting concepts. Therefore, there is a need to know the infrastructure.

.Form

The deployment view uses UML deployment diagrams to express the infrastructure. Nested diagrams show the internal structure of containers when needed.

.Further Information

See https://docs.arc42.org/section-7/[Deployment View] in the arc42 documentation.

****
endif::arc42help[]

=== Infrastructure Level 1

ifdef::arc42help[]
[role="arc42help"]
****
Describe (usually in a combination of diagrams, tables, and text):

* distribution of a system to multiple locations, environments, computers, processors, .., as well as physical connections between them
* important justifications or motivations for this deployment structure
* quality and/or performance features of this infrastructure
* mapping of software artifacts to elements of this infrastructure

For multiple environments or alternative deployments please copy and adapt this section of arc42 for all relevant environments.
****
endif::arc42help[]

[plantuml,"deployment-overview",png]
----
@startuml
!include <C4/C4_Deployment>

Deployment_Node(client, "Client Device"){
    Container(browser, "Web Browser", "Runs the React UI")
}

Deployment_Node(docker, "Docker Environment"){
    Deployment_Node(frontend, "Frontend Container"){
        Container(react_app, "React App", "TypeScript, Vite")
    }
    
    Deployment_Node(backend, "Backend Container"){
        Container(rust_logic, "Game Logic", "Rust")
    }
    
    Deployment_Node(db, "Database Container"){
        ContainerDb(mongodb, "MongoDB", "Game & user data")
    }
}

Rel(browser, react_app, "HTTPS")
Rel(react_app, rust_logic, "WebSocket")
Rel(rust_logic, mongodb, "MongoDB Protocol")

@enduml
----

Motivation::

Game Y uses Docker containers to separate frontend (React/Vite), backend (Rust game logic with WebSocket), and database (MongoDB). This ensures isolation, portability, and independent scaling of components. The containerized approach provides consistency across development and production environments.

Quality and/or Performance Features::

* *Real-time gameplay:* WebSocket enables low-latency bidirectional communication between players
* *Isolation:* Docker containers prevent component conflicts and ensure clean separation of concerns
* *Scalability:* Each component can scale independently based on load requirements
* *Portability:* The application runs consistently across different platforms and environments
* *Development efficiency:* Docker Compose orchestrates local development setup

Mapping of Building Blocks to Infrastructure::

[options="header"]
|===
| Building Block | Container | Technology
| User Interface | Frontend Container | React + TypeScript + Vite
| Game Logic & WebSocket | Backend Container | Rust
| Data Storage | Database Container | MongoDB
|===


=== Infrastructure Level 2

ifdef::arc42help[]
[role="arc42help"]
****
Here you can include the internal structure of (some) infrastructure elements from level 1.

Please copy the structure from level 1 for each selected element.
****
endif::arc42help[]

==== Backend Container

[plantuml,"backend-detail",png]
----
@startuml
node "Backend Container" {
    component "Game Engine" as engine
    component "WebSocket Server" as ws
    component "Win Checker" as win
    component "Board Manager" as board
    component "MongoDB Driver" as db
}

ws -> engine : Process moves
engine -> board : Update state
engine -> win : Check victory
engine -> db : Persist data

@enduml
----

The backend container runs the Rust application handling game logic, real-time WebSocket communication, and database operations. Key components include:

* *Game Engine:* Validates moves and enforces game rules
* *WebSocket Server:* Maintains persistent connections with both players for real-time updates
* *Win Condition Checker:* Detects when a connected chain of hexagonal cells touches all three sides
* *Board Manager:* Maintains the state of the hexagonal grid
* *MongoDB Driver:* Handles all database operations with connection pooling

==== MongoDB Container

[plantuml,"mongodb-detail",png]
----
@startuml
database "MongoDB" {
    folder "Collections" {
        component "users"
        component "games"
        component "game_history"
    }
}

note right of games
  Active game states,
  hexagonal board config,
  current turn
end note

@enduml
----

The MongoDB container stores all persistent data:

* *users collection:* User accounts, authentication credentials, and player statistics
* *games collection:* Active game sessions with current board state and turn information. The hexagonal board configuration is stored as an array of cell objects, indexed by gameId for quick retrieval
* *game_history collection:* Archive of completed games including complete move logs for replay and analytics

The database uses indexes on frequently queried fields (email for users, gameId for games) to optimize performance.