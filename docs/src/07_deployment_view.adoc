ifndef::imagesdir[:imagesdir: ../images]

[[section-deployment-view]]


== Deployment View

ifdef::arc42help[]
[role="arc42help"]
****
.Content
The deployment view describes:

 1. technical infrastructure used to execute your system, with infrastructure elements like geographical locations, environments, computers, processors, channels and net topologies as well as other infrastructure elements and

2. mapping of (software) building blocks to that infrastructure elements.

Often systems are executed in different environments, e.g. development environment, test environment, production environment. In such cases you should document all relevant environments.

Especially document a deployment view if your software is executed as distributed system with more than one computer, processor, server or container or when you design and construct your own hardware processors and chips.

From a software perspective it is sufficient to capture only those elements of an infrastructure that are needed to show a deployment of your building blocks. Hardware architects can go beyond that and describe an infrastructure to any level of detail they need to capture.

.Motivation
Software does not run without hardware.
This underlying infrastructure can and will influence a system and/or some
cross-cutting concepts. Therefore, there is a need to know the infrastructure.

.Form

The deployment view uses UML deployment diagrams to express the infrastructure. Nested diagrams show the internal structure of containers when needed.

.Further Information

See https://docs.arc42.org/section-7/[Deployment View] in the arc42 documentation.

****
endif::arc42help[]

=== Infrastructure Level 1

ifdef::arc42help[]
[role="arc42help"]
****
Describe (usually in a combination of diagrams, tables, and text):

* distribution of a system to multiple locations, environments, computers, processors, .., as well as physical connections between them
* important justifications or motivations for this deployment structure
* quality and/or performance features of this infrastructure
* mapping of software artifacts to elements of this infrastructure

For multiple environments or alternative deployments please copy and adapt this section of arc42 for all relevant environments.
****
endif::arc42help[]

[plantuml,"deployment-overview",png]
----
@startuml
!include <C4/C4_Deployment>

Deployment_Node(client, "Client Device", "Browser"){
    Container(browser, "Web Browser", "Runs the React UI", "Accesses port 80")
}

Deployment_Node(docker, "Docker Environment (docker-compose)"){
    Deployment_Node(frontend, "Webapp Container", "React + TypeScript + Vite, port 80"){
        Container(react_app, "React App", "TypeScript, Vite", "User interface and game board")
    }

    Deployment_Node(users_svc, "Users Container", "Node.js + Express, port 3000"){
        Container(users_service, "Users Service", "Node.js, Express", "User registration and management")
    }

    Deployment_Node(gamey_svc, "Gamey Container", "Rust, port 4000"){
        Container(gamey_service, "Gamey Service", "Rust", "Game logic engine and bot service")
    }

    Deployment_Node(db, "MongoDB Container", "mongo:7, port 27017"){
        ContainerDb(mongodb, "MongoDB", "NoSQL", "Persistent storage for players, games and history")
    }
}

Rel(browser, react_app, "HTTPS / HTTP", "port 80")
Rel(react_app, users_service, "REST API", "HTTP, port 3000")
Rel(react_app, gamey_service, "REST API", "HTTP, port 4000")
Rel(react_app, users_service, "Game results", "HTTP, port 3000")
Rel(users_service, mongodb, "MongoDB Protocol", "port 27017")

@enduml
----

Motivation::

Game Y uses Docker Compose to orchestrate four independent containers: the `webapp` (React frontend), the `users` service (Node.js/Express user management API), the `gamey` service (Rust game engine), and a `mongodb` container for persistent storage. This separation ensures that each service can be developed, built, and scaled independently. MongoDB is the chosen database because its document-oriented model fits naturally with the variable structure of game states and move histories, and it integrates well with the Node.js ecosystem.

Only the `users` service connects to MongoDB. This is a deliberate architectural decision: `gamey` manages active game state in memory during a match (which is sufficient for its role as a pure game engine), and once a game ends the result is sent to the `users` service, which is responsible for all persistence — player accounts, statistics, and game history. This avoids two services competing to write to the same database and keeps data ownership clear.

Quality and/or Performance Features::

* *Isolation:* Each service runs in its own Docker container, preventing dependency conflicts and simplifying upgrades.
* *Portability:* `docker-compose up --build` reproduces the full environment on any machine with Docker installed.
* *Independent scaling:* The `gamey` and `users` services can be scaled individually based on load without affecting the frontend.
* *Clear interface boundaries:* Services communicate only via HTTP REST, making the contracts explicit and testable.
* *Development efficiency:* Docker Compose orchestrates the full local setup with a single command; no manual service wiring is required.

Mapping of Building Blocks to Infrastructure::

[options="header"]
|===
| Building Block | Container | Technology | Exposed Port | Connects to
| User Interface | Webapp Container | React + TypeScript + Vite | 80 | Users (3000), Gamey (4000)
| User Management & Persistence | Users Container | Node.js + Express | 3000 | MongoDB (27017)
| Game Logic & Bot | Gamey Container | Rust (Cargo) | 4000 | —
| Persistent Storage | MongoDB Container | MongoDB 7 | 27017 (internal) | —
|===

==== Container Descriptions

*Webapp Container* — Serves the React single-page application to the browser. It is the only container directly accessible from outside the Docker network. It talks to the `users` service for everything related to the player (registration, login, stats, history) and to the `gamey` service for all game actions (creating a game, submitting a move, querying board state).

*Users Container* — Manages player accounts, authentication, statistics, and game history. It is the only service that connects to MongoDB, acting as the single gateway for all persistent data. When a game finishes, the result is reported here so it can be stored and reflected in player stats.

*Gamey Container* — A pure game engine written in Rust. It handles game creation, move validation, win condition checking, and bot moves entirely in memory. It has no database connection; active game state lives in memory for the duration of a match. Once the game ends, the result is communicated back to the frontend, which then reports it to the `users` service.

*MongoDB Container* — Provides persistent NoSQL storage exclusively for the `users` service. It runs as a Docker container within the same Compose network, so it is not directly accessible from outside.


=== Infrastructure Level 2

ifdef::arc42help[]
[role="arc42help"]
****
Here you can include the internal structure of (some) infrastructure elements from level 1.

Please copy the structure from level 1 for each selected element.
****
endif::arc42help[]

==== Gamey Container

[plantuml,"gamey-detail",png]
----
@startuml
node "Gamey Container (Rust, port 4000)" {
    component "Web Interface\n(HTTP handlers)" as web
    component "Game Engine\n(core game logic)" as engine
    component "Win Condition Checker" as win
    component "Bot Registry\n(AI opponents)" as bot
    component "Notation Parser\n(YEN / YGN)" as notation
}

web --> engine : Forwards moves and\ngame creation requests
engine --> win : Checks victory after each move
engine --> bot : Requests bot move\n(when playing vs AI)
engine --> notation : Encodes / decodes\ngame notation
@enduml
----

The Gamey container runs the Rust application that implements the full game logic for Game Y. Its internal components are:

* *Web Interface:* Exposes HTTP endpoints on port 4000 that the React frontend calls to create games, submit moves, and query game state.
* *Game Engine (core):* Contains the core data model — coordinates, board state, player management, and action dispatch. This is the authoritative source for game rules.
* *Win Condition Checker:* Evaluates after every move whether a player's connected chain of cells touches all three sides of the triangular board. Uses a graph traversal (DFS/BFS) over the hexagonal grid.
* *Bot Registry:* Maintains a set of registered bot strategies. When a player chooses to play against the computer, the bot registry selects the appropriate bot and returns its move to the game engine.
* *Notation Parser:* Supports YEN (Yovi Extended Notation) and YGN (Yovi Game Notation) for encoding and decoding move sequences. This enables game export, replay, and interoperability.

NOTE: The Win Condition Checker is an internal component of the Gamey service, not a separate deployment unit. It runs in-process within the Rust binary and is invoked synchronously during move processing. It is surfaced here to clarify its role, since it is architecturally significant and cross-referenced in the runtime view (see section 6).

==== Users Container

[plantuml,"users-detail",png]
----
@startuml
node "Users Container (Node.js, port 3000)" {
    component "Express HTTP Server" as server
    component "User Controller\n(/createuser)" as ctrl
    component "In-Memory User Store" as store
}

server --> ctrl : Routes POST /createuser
ctrl --> store : Registers new user
@enduml
----

The Users container is a lightweight Node.js/Express service. It exposes a REST endpoint (`POST /createuser`) that the React frontend calls during user registration. In the current implementation, user records are kept in-memory within the process; no external database is required. This service is designed to be replaced or extended with a persistent store in later development phases.

==== Webapp Container

The Webapp container serves the React single-page application compiled by Vite. It is served via a static file server on port 80. All game interactions are handled client-side in the browser, with REST calls made to the `users` service (port 3000) and the `gamey` service (port 4000). There is no server-side rendering; the container's only role is to deliver the compiled JavaScript and assets to the browser.

==== MongoDB Container

[plantuml,"mongodb-detail",png]
----
@startuml
database "MongoDB Container (port 27017)" {
    folder "Collections" {
        component "players" as players
        component "game_history" as history
    }
}

note right of players
  User accounts,
  credentials,
  player statistics
  (wins, losses)
end note

note right of history
  Completed games,
  full move logs,
  results for replay
end note
@enduml
----

The MongoDB container is exclusively used by the `users` service. It holds two collections:

* *players:* User accounts, hashed credentials, and per-player statistics (wins, losses, games played).
* *game_history:* Archived completed games including the full sequence of moves, the result, and the participants. This allows the frontend to display match history and enables future replay functionality.

`gamey` does not connect to MongoDB. Active game state is kept in memory within the Rust process for the duration of a match, which is sufficient for its role as a game engine. When a game concludes, the frontend reports the result to the `users` service, which writes it to `game_history`.

The MongoDB port (27017) is only exposed internally within the Docker Compose network and is not reachable from outside the host machine.

The docker-compose entry for this container is:

[source,yaml]
----
mongodb:
  image: mongo:7
  volumes:
    - mongo_data:/data/db
----

The named volume `mongo_data` ensures that data persists across container restarts. Note that the port is intentionally not published to the host — only the `users` container needs to reach it, and it can do so through the internal Docker network.