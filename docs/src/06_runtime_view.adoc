ifndef::imagesdir[:imagesdir: ../images]

[[section-runtime-view]]
== Runtime View


ifdef::arc42help[]
[role="arc42help"]
****
.Contents
The runtime view describes concrete behavior and interactions of the systemâ€™s building blocks in form of scenarios from the following areas:

* important use cases or features: how do building blocks execute them?
* interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems?
* operation and administration: launch, start-up, stop
* error and exception scenarios

Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their *architectural relevance*. It is *not* important to describe a large number of scenarios. You should rather document a representative selection.

.Motivation
You should understand how (instances of) building blocks of your system perform their job and communicate at runtime.
You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view).

.Form
There are many notations for describing scenarios, e.g.

* numbered list of steps (in natural language)
* activity diagrams or flow charts
* sequence diagrams
* BPMN or EPCs (event process chains)
* state machines
* ...


.Further Information

See https://docs.arc42.org/section-6/[Runtime View] in the arc42 documentation.

****
endif::arc42help[]

Here are the main runtime scenarios that demonstrate how Game Y's components interact during gameplay.

=== Player Makes a Move

[plantuml,"player-move-sequence",png]
----
@startuml
actor Player1
participant "React Frontend" as FE
participant "WebSocket Server" as WS
participant "Game Logic" as GL
participant "Game State Manager" as GSM
participant "MongoDB" as DB
actor Player2

Player1 -> FE: Clicks on hexagonal cell
FE -> FE: Validates cell is empty
alt Cell already occupied
    FE --> Player1: Show error notification
else Cell is empty (valid move)
    FE -> WS: Send move (cellId, playerId)
    WS -> GL: Process move request
    GL -> GSM: Get current game state
    GSM --> GL: Return game state
    GL -> GL: Apply move to board
    GL -> GL: Update player's territory
    GL -> GL: Check if all 3 sides touched
    GL -> GSM: Update game state
    GSM -> DB: Persist game state
    DB --> GSM: Confirmation
    GSM --> GL: State updated
    GL --> WS: Move confirmed + updated board
    WS --> FE: Broadcast board update
    FE --> Player1: Update UI (cell color)
    WS --> Player2: Broadcast board update
    Player2 <- FE: Update UI (cell color)
    alt All 3 sides touched
        FE --> Player1: Display victory
        FE --> Player2: Display defeat
    else Game continues
        FE --> Player2: Your turn notification
    end
end
@enduml
----

*Notable aspects:*

* The frontend performs client-side validation to provide immediate feedback
* WebSocket ensures real-time communication between both players
* Game Logic validates all moves server-side to prevent cheating
* The triangular board consists of hexagonal cells arranged in a triangular shape
* Win condition checks if a player's colored cells touch all three sides of the triangle
* Game state is persisted to MongoDB for game history and reconnection support
* Both players receive simultaneous updates through WebSocket broadcasting



=== Game Initialization (Matchmaking)

[plantuml,"game-init-sequence",png]
----
@startuml
actor Player1
actor Player2
participant "Frontend" as FE1
participant "Frontend" as FE2
participant "Matchmaking Service" as MM
participant "Game Creator" as GC
participant "WebSocket Server" as WS
participant "MongoDB" as DB

Player1 -> FE1: Click "Find Match"
FE1 -> MM: Request match
MM -> MM: Add to waiting queue
Player2 -> FE2: Click "Find Match"
FE2 -> MM: Request match
MM -> MM: Match players
MM -> GC: Create new game
GC -> GC: Initialize triangular board\nwith hexagonal cells
GC -> GC: Randomly assign colors
GC -> DB: Save initial game state
DB --> GC: Game created (gameId)
GC --> MM: Game ready (gameId)
MM -> WS: Establish game room
WS --> FE1: Game found (gameId, color, opponent)
WS --> FE2: Game found (gameId, color, opponent)
FE1 --> Player1: Navigate to game board
FE2 --> Player2: Navigate to game board
FE1 -> WS: Join game room
FE2 -> WS: Join game room
WS --> FE1: Initial board state
WS --> FE2: Initial board state
FE1 --> Player1: Display hexagonal board (waiting/your turn)
FE2 --> Player2: Display hexagonal board (waiting/your turn)
@enduml
----

*Notable aspects:*

* Matchmaking service maintains a queue of waiting players
* Players are matched on a first-come, first-served basis
* Each player is randomly assigned a color to ensure fairness
* The triangular board is composed of hexagonal cells arranged in a triangular pattern
* Both players connect to the same WebSocket room for real-time updates
* Initial game state is persisted before players enter the game
* Players receive notification about whose turn it is (textual or visual)



=== Win Condition Detection

[plantuml,"win-detection-sequence",png]
----
@startuml
participant "Game Logic" as GL
participant "Board Analyzer" as BA
participant "Path Finder" as PF
participant "Game State Manager" as GSM

GL -> BA: Check win condition (playerId)
BA -> BA: Get all cells of player's color
BA -> PF: Find connected path touching all 3 sides
PF -> PF: Build graph of adjacent hexagonal cells\nof player's color
PF -> PF: Execute graph traversal algorithm\n(DFS/BFS from edge cells)
PF -> PF: Check if connected component\ntouches all 3 triangle sides
alt Connected path touches all 3 sides
    PF --> BA: Winning chain found
    BA --> GL: Player has won
    GL -> GSM: Set game status = "finished"
    GL -> GSM: Set winner = playerId
    GSM -> GSM: Record game result
else No complete chain
    PF --> BA: Chain incomplete (touching only [X] side(s))
    BA --> GL: Game continues
end
@enduml
----

*Notable aspects:*

* Win condition checked after every move
* Player wins when a connected chain of their colored cells touches all three sides of the triangular board
* Uses graph traversal (DFS/BFS) to detect connected components in the hexagonal grid
* Hexagonal cells have up to 6 adjacent neighbors for connectivity checking
* Efficient algorithm analyzes only the moving player's cells

